"""
Vulnerability Scanner Module
Detects various AD vulnerabilities: ZeroLogon, PrintNightmare, PetitPotam, Shadow Credentials
"""

import logging
from typing import List, Dict, Any, Optional
from core.constants import RiskTypes, Severity, MITRETechniques

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """Scans for various Active Directory vulnerabilities."""
    
    def __init__(self, ldap_connection):
        """
        Initialize vulnerability scanner.
        
        Args:
            ldap_connection: LDAPConnection instance
        """
        self.ldap = ldap_connection
    
    def scan_zerologon(self, computers: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Scan for ZeroLogon (CVE-2020-1472) vulnerability.
        
        Args:
            computers: List of computer dictionaries
        
        Returns:
            List of risk dictionaries for ZeroLogon
        """
        risks = []
        
        try:
            # ZeroLogon affects Windows Server 2008 R2 and later Domain Controllers
            # Check for DCs with vulnerable OS versions
            vulnerable_oses = [
                'Windows Server 2008 R2',
                'Windows Server 2012',
                'Windows Server 2012 R2',
                'Windows Server 2016',
                'Windows Server 2019'
            ]
            
            for computer in computers:
                computer_name = computer.get('name')
                os_name = computer.get('operatingSystem') or ''
                os_version = computer.get('operatingSystemVersion') or ''
                
                if not computer_name:
                    continue
                
                # Ensure os_name is a string
                if not isinstance(os_name, str):
                    os_name = str(os_name) if os_name else ''
                
                # Check if it's a Domain Controller
                # DCs typically have "DC" in their name or are in Domain Controllers OU
                is_dc = 'DC' in computer_name.upper() or (os_name and 'DOMAIN CONTROLLER' in os_name.upper())
                
                if is_dc:
                    # Check if OS is potentially vulnerable
                    is_vulnerable = os_name and any(vuln_os in os_name for vuln_os in vulnerable_oses)
                    
                    if is_vulnerable:
                        risks.append({
                            'type': RiskTypes.ZEROLOGON_VULNERABLE,
                            'severity': Severity.CRITICAL,
                            'title': f'Potential ZeroLogon Vulnerability: {computer_name}',
                            'description': (
                                f"Domain Controller '{computer_name}' running '{os_name}' may be vulnerable "
                                "to ZeroLogon (CVE-2020-1472). This allows unauthenticated attackers to "
                                "set an empty password for the computer account."
                            ),
                            'affected_object': computer_name,
                            'object_type': 'computer',
                            'os_info': {
                                'name': os_name,
                                'version': os_version
                            },
                            'cve': 'CVE-2020-1472',
                            'impact': (
                                'ZeroLogon allows an unauthenticated attacker to set an empty password for '
                                'the Domain Controller computer account, enabling full domain compromise.'
                            ),
                            'attack_scenario': (
                                f"An attacker can exploit ZeroLogon against '{computer_name}' to set an empty "
                                "password, then use DCSync to extract all domain password hashes, leading to "
                                "complete domain compromise."
                            ),
                            'mitigation': (
                                'Apply Microsoft security updates for CVE-2020-1472. Ensure all Domain Controllers '
                                'are patched. Enable Netlogon secure channel signing and sealing. Monitor for '
                                'suspicious Netlogon authentication attempts.'
                            ),
                            'cis_reference': 'CIS Benchmark requires all security updates to be applied',
                            'mitre_attack': MITRETechniques.EXPLOIT_PUBLIC_FACING_APPLICATION,
                            'exploitation_tools': [
                                'zerologon_tester.py',
                                'CVE-2020-1472 exploit',
                                'Impacket secretsdump (after exploitation)'
                            ]
                        })
            
            logger.info(f"Found {len(risks)} potential ZeroLogon vulnerabilities")
            return risks
            
        except Exception as e:
            logger.error(f"Error scanning for ZeroLogon: {str(e)}")
            return []
    
    def scan_printnightmare(self, computers: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Scan for PrintNightmare vulnerability (CVE-2021-1675, CVE-2021-34527).
        
        Args:
            computers: List of computer dictionaries
        
        Returns:
            List of risk dictionaries for PrintNightmare
        """
        risks = []
        
        try:
            # PrintNightmare affects Windows systems with Print Spooler service enabled
            # Check for systems that might have print spooler running
            
            for computer in computers:
                computer_name = computer.get('name')
                if not computer_name:
                    continue
                
                # Check if system has print-related attributes or SPNs
                spns = computer.get('servicePrincipalName', []) or []
                if not isinstance(spns, list):
                    spns = [spns] if spns else []
                
                # Check for print spooler SPNs
                has_print_spooler = any('spooler' in spn.lower() or 'print' in spn.lower() for spn in spns)
                
                if has_print_spooler:
                    risks.append({
                        'type': RiskTypes.PRINTNIGHTMARE_VULNERABLE,
                        'severity': Severity.HIGH,
                        'title': f'Potential PrintNightmare Risk: {computer_name}',
                        'description': (
                            f"Computer '{computer_name}' appears to have Print Spooler service configured. "
                            "If unpatched, it may be vulnerable to PrintNightmare (CVE-2021-1675, CVE-2021-34527)."
                        ),
                        'affected_object': computer_name,
                        'object_type': 'computer',
                        'spns': [spn for spn in spns if 'print' in spn.lower() or 'spooler' in spn.lower()],
                        'cve': 'CVE-2021-1675, CVE-2021-34527',
                        'impact': (
                            'PrintNightmare allows remote code execution and local privilege escalation through '
                            'the Print Spooler service. Attackers can install malicious printer drivers.'
                        ),
                        'attack_scenario': (
                            f"An attacker can exploit PrintNightmare on '{computer_name}' to execute code as SYSTEM, "
                            "enabling privilege escalation and lateral movement."
                        ),
                        'mitigation': (
                            'Apply Microsoft security updates for CVE-2021-1675 and CVE-2021-34527. '
                            'Disable Print Spooler service on systems that do not need printing. Restrict '
                            'printer driver installation. Enable Point and Print restrictions.'
                        ),
                        'cis_reference': 'CIS Benchmark requires all security updates to be applied',
                        'mitre_attack': MITRETechniques.EXPLOITATION_PRIVILEGE_ESCALATION,
                        'exploitation_tools': [
                            'PrintNightmare exploit',
                            'CVE-2021-1675 exploit',
                            'Impacket rpcdump'
                        ]
                    })
            
            logger.info(f"Found {len(risks)} potential PrintNightmare risks")
            return risks
            
        except Exception as e:
            logger.error(f"Error scanning for PrintNightmare: {str(e)}")
            return []
    
    def scan_petitpotam(self, computers: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Scan for PetitPotam vulnerability (MS-EFSRPC abuse).
        
        Args:
            computers: List of computer dictionaries
        
        Returns:
            List of risk dictionaries for PetitPotam
        """
        risks = []
        
        try:
            # PetitPotam affects systems with MS-EFSRPC or MS-DFSNM protocols exposed
            # This is typically Domain Controllers
            
            for computer in computers:
                computer_name = computer.get('name')
                if not computer_name:
                    continue
                
                # Check if it's a Domain Controller
                is_dc = 'DC' in computer_name.upper()
                
                if is_dc:
                    risks.append({
                        'type': RiskTypes.PETITPOTAM_VULNERABLE,
                        'severity': Severity.HIGH,
                        'title': f'Potential PetitPotam Risk: {computer_name}',
                        'description': (
                            f"Domain Controller '{computer_name}' may be vulnerable to PetitPotam attack, "
                            "which forces authentication to attacker-controlled systems via MS-EFSRPC or MS-DFSNM."
                        ),
                        'affected_object': computer_name,
                        'object_type': 'computer',
                        'impact': (
                            'PetitPotam can force Domain Controllers to authenticate to attacker-controlled '
                            'systems, enabling NTLM relay attacks and potentially gaining Domain Admin access.'
                        ),
                        'attack_scenario': (
                            f"An attacker can use PetitPotam to force '{computer_name}' to authenticate to "
                            "an attacker-controlled system, then relay that authentication to gain Domain Admin "
                            "privileges through NTLM relay attacks."
                        ),
                        'mitigation': (
                            'Enable Extended Protection for Authentication (EPA) on Domain Controllers. '
                            'Disable NTLM authentication where possible. Enable SMB signing. Restrict '
                            'MS-EFSRPC and MS-DFSNM access. Apply security updates.'
                        ),
                        'cis_reference': 'CIS Benchmark requires NTLM relay protection',
                        'mitre_attack': MITRETechniques.STEAL_FORGE_KERBEROS_GOLDEN,
                        'exploitation_tools': [
                            'PetitPotam',
                            'Impacket ntlmrelayx',
                            'Responder'
                        ]
                    })
            
            logger.info(f"Found {len(risks)} potential PetitPotam risks")
            return risks
            
        except Exception as e:
            logger.error(f"Error scanning for PetitPotam: {str(e)}")
            return []
    
    def scan_shadow_credentials(self, users: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Scan for Shadow Credentials (Key Credentials abuse).
        
        Args:
            users: List of user dictionaries
        
        Returns:
            List of risk dictionaries for Shadow Credentials
        """
        risks = []
        
        try:
            # Shadow Credentials involve adding Key Credentials to user accounts
            # This allows PKINIT authentication without knowing the password
            
            for user in users:
                username = user.get('sAMAccountName')
                if not username:
                    continue
                
                # Check for msDS-KeyCredentialLink attribute
                # This would require reading the attribute, which may not be accessible
                # We'll provide general guidance
                
                # Check if user is in privileged groups (higher risk)
                member_of = user.get('memberOf', []) or []
                if not isinstance(member_of, list):
                    member_of = [member_of] if member_of else []
                
                is_privileged = False
                for group_dn in member_of:
                    group_name = self._extract_group_name(group_dn)
                    if group_name and any(priv in group_name.upper() for priv in 
                        ['DOMAIN ADMINS', 'ENTERPRISE ADMINS']):
                        is_privileged = True
                        break
                
                if is_privileged:
                    risks.append({
                        'type': RiskTypes.SHADOW_CREDENTIALS,
                        'severity': Severity.CRITICAL,
                        'title': f'Shadow Credentials Risk: {username}',
                        'description': (
                            f"Privileged user '{username}' may be vulnerable to Shadow Credentials attack. "
                            "Attackers can add Key Credentials to enable PKINIT authentication."
                        ),
                        'affected_object': username,
                        'object_type': 'user',
                        'impact': (
                            'Shadow Credentials allow attackers to add Key Credentials to user accounts, '
                            'enabling PKINIT authentication without knowing the password. This can lead to '
                            'privilege escalation.'
                        ),
                        'attack_scenario': (
                            f"An attacker with write access to '{username}' can add Key Credentials, then "
                            "use PKINIT to authenticate as that user without knowing the password, gaining "
                            "their privileges."
                        ),
                        'mitigation': (
                            'Restrict write access to msDS-KeyCredentialLink attribute. Monitor for '
                            'unauthorized Key Credential additions. Use privileged access management. '
                            'Review ACLs on user objects.'
                        ),
                        'cis_reference': 'CIS Benchmark requires strict control over Key Credentials',
                        'mitre_attack': MITRETechniques.STEAL_FORGE_KERBEROS_SILVER,
                        'exploitation_tools': [
                            'Whisker (Shadow Credentials)',
                            'Rubeus',
                            'Impacket'
                        ]
                    })
            
            logger.info(f"Found {len(risks)} potential Shadow Credentials risks")
            return risks
            
        except Exception as e:
            logger.error(f"Error scanning for Shadow Credentials: {str(e)}")
            return []
    
    def scan_nopac(self, computers: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Scan for NoPac vulnerability (CVE-2021-42278, CVE-2021-42287).
        sAMAccountName spoofing allows privilege escalation to Domain Admin.
        
        Args:
            computers: List of computer dictionaries
        
        Returns:
            List of risk dictionaries for NoPac
        """
        risks = []
        try:
            vulnerable_oses = [
                'Windows Server 2016',
                'Windows Server 2019',
                'Windows Server 2022'
            ]
            for computer in computers:
                computer_name = computer.get('name')
                os_name = computer.get('operatingSystem') or ''
                if not computer_name:
                    continue
                if not isinstance(os_name, str):
                    os_name = str(os_name) if os_name else ''
                is_dc = 'DC' in computer_name.upper() or (
                    os_name and 'DOMAIN CONTROLLER' in os_name.upper()
                )
                if is_dc and any(v in os_name for v in vulnerable_oses):
                    risks.append({
                        'type': RiskTypes.NOPAC_VULNERABLE,
                        'severity': Severity.CRITICAL,
                        'title': f'Potential NoPac Vulnerability: {computer_name}',
                        'description': (
                            f"Domain Controller '{computer_name}' running '{os_name}' may be vulnerable "
                            "to NoPac (CVE-2021-42278, CVE-2021-42287). Unpatched DCs allow sAMAccountName "
                            "spoofing leading to Domain Admin privilege escalation."
                        ),
                        'affected_object': computer_name,
                        'object_type': 'computer',
                        'cve': 'CVE-2021-42278, CVE-2021-42287',
                        'impact': (
                            'NoPac allows attackers to impersonate Domain Controllers by spoofing '
                            'sAMAccountName, then request a TGT with PAC. This leads to Domain Admin compromise.'
                        ),
                        'attack_scenario': (
                            f"An attacker with a low-privilege account can exploit NoPac against '{computer_name}' "
                            "to escalate to Domain Admin by abusing the SAMR and LSA protocols."
                        ),
                        'mitigation': (
                            'Apply KB5008602 (2021-11) or later security updates to all Domain Controllers. '
                            'Verify all DCs have the November 2021 or later cumulative update applied.'
                        ),
                        'cis_reference': 'CIS Benchmark requires all security updates to be applied',
                        'mitre_attack': MITRETechniques.EXPLOITATION_PRIVILEGE_ESCALATION,
                        'exploitation_tools': ['NoPac', 'sam_the_admin.py', 'Impacket']
                    })
            logger.info(f"Found {len(risks)} potential NoPac vulnerabilities")
            return risks
        except Exception as e:
            logger.error(f"Error scanning for NoPac: {str(e)}")
            return []
    
    def _extract_group_name(self, group_dn: str) -> Optional[str]:
        """Extract group name from DN."""
        if not group_dn:
            return None
        if 'CN=' in group_dn:
            try:
                cn_part = group_dn.split('CN=')[1].split(',')[0]
                return cn_part
            except Exception:
                return None
        return group_dn
