"""
Exploitability Scorer Module
Calculates exploitability scores for detected risks
"""

import logging
from typing import Dict, Any, List, Optional
from core.constants import RiskTypes, MITRETechniques

logger = logging.getLogger(__name__)


class ExploitabilityScorer:
    """Calculates exploitability scores for security risks."""
    
    # Exploitability scores based on risk type
    EXPLOITABILITY_SCORES = {
        RiskTypes.PASSWORD_NOT_REQUIRED: {
            'base_score': 10.0,  # CVSS-like (0-10)
            'complexity': 'Low',
            'attack_vector': 'Network',
            'user_interaction': 'None',
            'privileges_required': 'None'
        },
        RiskTypes.KERBEROS_PREAUTH_DISABLED: {
            'base_score': 8.5,
            'complexity': 'Low',
            'attack_vector': 'Network',
            'user_interaction': 'None',
            'privileges_required': 'None'
        },
        RiskTypes.UNCONSTRAINED_DELEGATION: {
            'base_score': 8.0,
            'complexity': 'Medium',
            'attack_vector': 'Network',
            'user_interaction': 'None',
            'privileges_required': 'Low'
        },
        RiskTypes.USER_WITH_SPN: {
            'base_score': 6.5,
            'complexity': 'Low',
            'attack_vector': 'Network',
            'user_interaction': 'None',
            'privileges_required': 'None'
        },
        RiskTypes.ACL_GENERIC_ALL: {
            'base_score': 9.0,
            'complexity': 'Low',
            'attack_vector': 'Network',
            'user_interaction': 'None',
            'privileges_required': 'Low'
        },
        RiskTypes.ACL_DCSYNC: {
            'base_score': 9.5,
            'complexity': 'Low',
            'attack_vector': 'Network',
            'user_interaction': 'None',
            'privileges_required': 'Low'
        },
        RiskTypes.EOL_OPERATING_SYSTEM: {
            'base_score': 7.0,
            'complexity': 'Low',
            'attack_vector': 'Network',
            'user_interaction': 'None',
            'privileges_required': 'None'
        },
        RiskTypes.DELEGATION_PRIVILEGE_ESCALATION: {
            'base_score': 9.0,
            'complexity': 'Medium',
            'attack_vector': 'Network',
            'user_interaction': 'None',
            'privileges_required': 'Low'
        }
    }
    
    # Known public exploits mapping
    PUBLIC_EXPLOITS = {
        RiskTypes.KERBEROS_PREAUTH_DISABLED: [
            'AS-REP Roasting (Impacket GetNPUsers)',
            'Rubeus asreproast'
        ],
        RiskTypes.UNCONSTRAINED_DELEGATION: [
            'Mimikatz sekurlsa::tickets',
            'Rubeus monitor',
            'MS14-068 (if applicable)'
        ],
        RiskTypes.USER_WITH_SPN: [
            'Kerberoasting (Impacket GetUserSPNs)',
            'Rubeus kerberoast'
        ],
        RiskTypes.ACL_DCSYNC: [
            'Mimikatz lsadump::dcsync',
            'Impacket secretsdump'
        ],
        RiskTypes.EOL_OPERATING_SYSTEM: [
            'Various CVE exploits (OS-specific)',
            'EternalBlue (MS17-010) for older systems'
        ]
    }
    
    # Metasploit modules mapping
    METASPLOIT_MODULES = {
        RiskTypes.KERBEROS_PREAUTH_DISABLED: [
            'auxiliary/admin/kerberos/get_user_spns'
        ],
        RiskTypes.UNCONSTRAINED_DELEGATION: [
            'auxiliary/admin/kerberos/ms14_068_kerberos_checksum'
        ],
        RiskTypes.USER_WITH_SPN: [
            'auxiliary/admin/kerberos/get_user_spns'
        ],
        RiskTypes.ACL_DCSYNC: [
            'auxiliary/admin/dcerpc/samr_computer'
        ]
    }
    
    def __init__(self):
        """Initialize exploitability scorer."""
        pass
    
    def score_risk(self, risk: Dict[str, Any]) -> Dict[str, Any]:
        """
        Calculate exploitability score for a risk.
        
        Args:
            risk: Risk dictionary
        
        Returns:
            Dictionary with exploitability information
        """
        risk_type = risk.get('type', '')
        
        # Get base exploitability data
        exploit_data = self.EXPLOITABILITY_SCORES.get(risk_type, {
            'base_score': 5.0,
            'complexity': 'Unknown',
            'attack_vector': 'Network',
            'user_interaction': 'None',
            'privileges_required': 'Low'
        })
        
        # Adjust score based on context
        adjusted_score = self._adjust_score(risk, exploit_data['base_score'])
        
        # Get public exploits
        public_exploits = self.PUBLIC_EXPLOITS.get(risk_type, [])
        
        # Get Metasploit modules
        metasploit_modules = self.METASPLOIT_MODULES.get(risk_type, [])
        
        # Calculate difficulty
        difficulty = self._calculate_difficulty(exploit_data, adjusted_score)
        
        return {
            'exploitability_score': round(adjusted_score, 1),
            'base_score': exploit_data['base_score'],
            'complexity': exploit_data['complexity'],
            'difficulty': difficulty,
            'attack_vector': exploit_data['attack_vector'],
            'user_interaction': exploit_data['user_interaction'],
            'privileges_required': exploit_data['privileges_required'],
            'public_exploits': public_exploits,
            'metasploit_modules': metasploit_modules,
            'exploitation_tools': self._get_exploitation_tools(risk_type),
            'proof_of_concept': self._generate_poc_description(risk_type, risk)
        }
    
    def _adjust_score(self, risk: Dict[str, Any], base_score: float) -> float:
        """
        Adjust exploitability score based on risk context.
        
        Args:
            risk: Risk dictionary
            base_score: Base exploitability score
        
        Returns:
            Adjusted score
        """
        score = base_score
        
        # Increase score if object is privileged
        object_type = risk.get('object_type', '').lower()
        if object_type == 'user':
            affected_object = risk.get('affected_object', '')
            # Check if user has adminCount or is in privileged groups
            if risk.get('adminCount') or 'admin' in affected_object.lower():
                score += 1.0
        
        # Increase score if multiple similar risks exist (prevalence)
        prevalence_count = risk.get('prevalence_count', 1)
        if prevalence_count > 5:
            score += 0.5
        
        # Cap at 10.0
        return min(10.0, score)
    
    def _calculate_difficulty(self, exploit_data: Dict[str, Any], score: float) -> str:
        """
        Calculate exploitation difficulty.
        
        Args:
            exploit_data: Exploitability data
            score: Exploitability score
        
        Returns:
            Difficulty level string
        """
        if score >= 9.0:
            return 'Very Easy'
        elif score >= 7.0:
            return 'Easy'
        elif score >= 5.0:
            return 'Medium'
        elif score >= 3.0:
            return 'Hard'
        else:
            return 'Very Hard'
    
    def _get_exploitation_tools(self, risk_type: str) -> List[str]:
        """
        Get list of exploitation tools for risk type.
        
        Args:
            risk_type: Risk type identifier
        
        Returns:
            List of tool names
        """
        tools_map = {
            RiskTypes.KERBEROS_PREAUTH_DISABLED: [
                'Impacket GetNPUsers',
                'Rubeus asreproast',
                'CrackMapExec'
            ],
            RiskTypes.USER_WITH_SPN: [
                'Impacket GetUserSPNs',
                'Rubeus kerberoast',
                'CrackMapExec'
            ],
            RiskTypes.UNCONSTRAINED_DELEGATION: [
                'Mimikatz',
                'Rubeus',
                'Impacket'
            ],
            RiskTypes.ACL_DCSYNC: [
                'Mimikatz lsadump::dcsync',
                'Impacket secretsdump',
                'DSInternals'
            ],
            RiskTypes.ACL_GENERIC_ALL: [
                'PowerView',
                'Impacket'
            ]
        }
        
        return tools_map.get(risk_type, ['Manual exploitation required'])
    
    def _generate_poc_description(self, risk_type: str, risk: Dict[str, Any]) -> str:
        """
        Generate proof-of-concept description (theoretical, no actual exploit code).
        
        Args:
            risk_type: Risk type identifier
            risk: Risk dictionary
        
        Returns:
            POC description string
        """
        affected_object = risk.get('affected_object', 'Unknown')
        
        poc_descriptions = {
            RiskTypes.KERBEROS_PREAUTH_DISABLED: (
                f"An attacker can request a Kerberos ticket for user '{affected_object}' "
                "without preauthentication, then attempt to crack the password hash offline "
                "using tools like hashcat or john the ripper. This does not trigger account lockout."
            ),
            RiskTypes.USER_WITH_SPN: (
                f"An attacker can request a Kerberos service ticket for the SPN associated with "
                f"user '{affected_object}', then attempt to crack the service account password "
                "hash offline using Kerberoasting techniques."
            ),
            RiskTypes.UNCONSTRAINED_DELEGATION: (
                f"If an attacker compromises the computer '{affected_object}' with unconstrained "
                "delegation, they can capture Kerberos tickets from any user who authenticates "
                "to it, potentially including domain administrators."
            ),
            RiskTypes.ACL_DCSYNC: (
                f"An attacker with DCSync rights on '{affected_object}' can request password "
                "hashes for any user in the domain, including domain administrators, using tools "
                "like Mimikatz or Impacket."
            ),
            RiskTypes.PASSWORD_NOT_REQUIRED: (
                f"An attacker can authenticate to account '{affected_object}' without providing "
                "any password, gaining immediate access to the account and its associated permissions."
            )
        }
        
        return poc_descriptions.get(risk_type, 
            f"Theoretical exploitation path exists for '{affected_object}'. "
            "Consult security advisories and penetration testing frameworks for specific techniques.")
